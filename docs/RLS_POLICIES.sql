-- RLS 策略示例（按需调整字段名/表名）-- 约定：应用层每次请求必须 SET LOCAL:--   app.user_id, app.is_admin, app.group_ids-- ---------- helper functions ----------CREATE OR REPLACE FUNCTION app_user_id()RETURNS uuid LANGUAGE sql STABLE AS $$SELECT NULLIF(current_setting('app.user_id', true), '')::uuid;$$;CREATE OR REPLACE FUNCTION app_is_admin()RETURNS boolean LANGUAGE sql STABLE AS $$SELECT COALESCE(NULLIF(current_setting('app.is_admin', true), '')::boolean, false);$$;CREATE OR REPLACE FUNCTION app_group_ids()RETURNS uuid[] LANGUAGE sql STABLE AS $$SELECT COALESCE(string_to_array(NULLIF(current_setting('app.group_ids', true), ''), ',')::uuid[],ARRAY[]::uuid[]);$$;CREATE OR REPLACE FUNCTION app_can_write_group(gid uuid)RETURNS boolean LANGUAGE sql STABLE AS $$SELECT app_is_admin() OR gid = ANY(app_group_ids());$$;-- ---------- project ----------ALTER TABLE project ENABLE ROW LEVEL SECURITY;CREATE POLICY project_select_policy ON projectFOR SELECT USING (app_is_admin()OR group_id = ANY(app_group_ids())OR EXISTS (SELECT 1 FROM project_member pm WHERE pm.project_id = project.id AND pm.user_id = app_user_id())OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'project'AND tg.object_id = project.idAND tg.expires_at > now()));CREATE POLICY project_insert_policy ON projectFOR INSERT WITH CHECK (app_can_write_group(group_id));CREATE POLICY project_update_policy ON projectFOR UPDATE USING (app_is_admin()OR group_id = ANY(app_group_ids())OR EXISTS (SELECT 1 FROM project_member pm WHERE pm.project_id = project.id AND pm.user_id = app_user_id())OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'project'AND tg.object_id = project.idAND tg.expires_at > now()))WITH CHECK (app_can_write_group(group_id));CREATE POLICY project_delete_policy ON projectFOR DELETE USING (app_is_admin());-- ---------- case ----------ALTER TABLE "case" ENABLE ROW LEVEL SECURITY;CREATE POLICY case_select_policy ON "case"FOR SELECT USING (app_is_admin()OR group_id = ANY(app_group_ids())OR EXISTS (SELECT 1 FROM case_member cm WHERE cm.case_id = "case".id AND cm.user_id = app_user_id())OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'case'AND tg.object_id = "case".idAND tg.expires_at > now()));CREATE POLICY case_insert_policy ON "case"FOR INSERT WITH CHECK (app_can_write_group(group_id));-- 写权限：默认只允许战区内或 admin，跨战区写必须走 temp_grant(permission_set.can_edit=true)CREATE POLICY case_update_policy ON "case"FOR UPDATE USING (app_is_admin()OR group_id = ANY(app_group_ids())OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'case'AND tg.object_id = "case".idAND tg.expires_at > now()AND (tg.permission_set->>'can_edit') = 'true'))WITH CHECK (app_can_write_group(group_id));CREATE POLICY case_delete_policy ON "case"FOR DELETE USING (app_is_admin());-- ---------- task ----------ALTER TABLE task ENABLE ROW LEVEL SECURITY;CREATE POLICY task_select_policy ON taskFOR SELECT USING (app_is_admin()OR group_id = ANY(app_group_ids())OR assignee_user_id = app_user_id()OR EXISTS (SELECT 1 FROM case_member cm WHERE cm.case_id = task.case_id AND cm.user_id = app_user_id())OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'task'AND tg.object_id = task.idAND tg.expires_at > now()));CREATE POLICY task_insert_policy ON taskFOR INSERT WITH CHECK (app_can_write_group(group_id));CREATE POLICY task_update_policy ON taskFOR UPDATE USING (app_is_admin()OR group_id = ANY(app_group_ids())OR assignee_user_id = app_user_id()OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'task'AND tg.object_id = task.idAND tg.expires_at > now()AND (tg.permission_set->>'can_edit') = 'true'))WITH CHECK (app_can_write_group(group_id));CREATE POLICY task_delete_policy ON taskFOR DELETE USING (app_is_admin());-- ---------- payment ----------ALTER TABLE payment ENABLE ROW LEVEL SECURITY;CREATE POLICY payment_select_policy ON paymentFOR SELECT USING (app_is_admin()OR group_id = ANY(app_group_ids())OR EXISTS (SELECT 1 FROM case_member cm WHERE cm.case_id = payment.case_id AND cm.user_id = app_user_id())OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'payment'AND tg.object_id = payment.idAND tg.expires_at > now()));CREATE POLICY payment_insert_policy ON paymentFOR INSERT WITH CHECK (app_can_write_group(group_id));CREATE POLICY payment_update_policy ON paymentFOR UPDATE USING (app_is_admin()OR group_id = ANY(app_group_ids())OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'payment'AND tg.object_id = payment.idAND tg.expires_at > now()AND (tg.permission_set->>'can_edit') = 'true'))WITH CHECK (app_can_write_group(group_id));CREATE POLICY payment_delete_policy ON paymentFOR DELETE USING (app_is_admin());-- ---------- file_store ----------ALTER TABLE file_store ENABLE ROW LEVEL SECURITY;CREATE POLICY file_select_policy ON file_storeFOR SELECT USING (app_is_admin()OR group_id = ANY(app_group_ids())OR created_by = app_user_id()OR EXISTS (SELECT 1 FROM temp_grant tgWHERE tg.user_id = app_user_id()AND tg.object_type = 'file'AND tg.object_id = file_store.idAND tg.expires_at > now()));CREATE POLICY file_insert_policy ON file_storeFOR INSERT WITH CHECK (app_can_write_group(group_id));CREATE POLICY file_update_policy ON file_storeFOR UPDATE USING (app_is_admin()OR group_id = ANY(app_group_ids())OR created_by = app_user_id())WITH CHECK (app_can_write_group(group_id));CREATE POLICY file_delete_policy ON file_storeFOR DELETE USING (app_is_admin());-- ---------- event_outbox ----------ALTER TABLE event_outbox ENABLE ROW LEVEL SECURITY;-- 建议：worker 通过数据库角色控制，而不是依赖RLS；这里给最小策略CREATE POLICY outbox_select_policy ON event_outboxFOR SELECT USING (app_is_admin() OR group_id = ANY(app_group_ids()));CREATE POLICY outbox_insert_policy ON event_outboxFOR INSERT WITH CHECK (app_is_admin() OR group_id = ANY(app_group_ids()));-- 注意：worker 更新 status 需要权限；生产中建议给 worker 单独 role 授权更新 outboxCREATE POLICY outbox_update_policy ON event_outboxFOR UPDATE USING (app_is_admin())WITH CHECK (app_is_admin());-- ---------- payment immutability trigger ----------CREATE OR REPLACE FUNCTION prevent_payment_core_update()RETURNS trigger LANGUAGE plpgsql AS $$BEGINIF (NEW.amount IS DISTINCT FROM OLD.amount)OR (NEW.paid_at IS DISTINCT FROM OLD.paid_at)OR (NEW.pay_channel IS DISTINCT FROM OLD.pay_channel)OR (NEW.payer_name IS DISTINCT FROM OLD.payer_name)OR (NEW.bank_last4 IS DISTINCT FROM OLD.bank_last4)OR (NEW.case_id IS DISTINCT FROM OLD.case_id)OR (NEW.project_id IS DISTINCT FROM OLD.project_id)OR (NEW.group_id IS DISTINCT FROM OLD.group_id)THENRAISE EXCEPTION 'payment core fields are immutable; use correction flow';END IF;RETURN NEW;END;$$;DROP TRIGGER IF EXISTS trg_prevent_payment_core_update ON payment;CREATE TRIGGER trg_prevent_payment_core_updateBEFORE UPDATE ON paymentFOR EACH ROWEXECUTE FUNCTION prevent_payment_core_update();